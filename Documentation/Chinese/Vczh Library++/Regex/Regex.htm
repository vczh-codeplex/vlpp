<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../DocStyle.css" />
<title>Vczh Library++ 正则表达式</title>
</head>
<body>
<h1>namespace regex;</h1>
<h2><a name="RegexString">RegexString</a></h2>
<p>RegexString记录输入字符串的一个部分</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员函数</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">int Start()const</td></tr>
<tr><td>[返回值]</td><td>字符串部分的开始位置</td></tr>

<tr><td colspan="2" class="method_sign">int Length()const</td></tr>
<tr><td>[返回值]</td><td>字符串部分的长度</td></tr>

<tr><td colspan="2" class="method_sign">const WString& Value()const</td></tr>
<tr><td>[返回值]</td><td>获得一个WString表达字符串部分</td></tr>

<tr><td colspan="2" class="method_sign">bool operator==(const RegexString& string)const</td></tr>
<tr><td>[返回值]</td><td>比较结果</td></tr>
<tr><td>string</td><td>被比较的字符串部分</td></tr>
</tbody>
</table>
<h2><a name="RegexMatch">RegexMatch</a></h2>
<p>RegexMatch用来存放正则表达式匹配信息</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员函数</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">bool Success()const</td></tr>
<tr><td>[返回值]</td><td>True代表这是一个成功匹配，否则为false</td></tr>

<tr><td colspan="2" class="method_sign">const RegexString& Result()const</td></tr>
<tr><td>[返回值]</td><td>匹配成功的字符串</td></tr>

<tr><td colspan="2" class="method_sign">collections::IReadonlyList&lt;RegexString&gt; Captures()const</td></tr>
<tr><td>[返回值]</td><td>匿名捕获列表</td></tr>

<tr><td colspan="2" class="method_sign">collections::IReadonlyGroup&lt;WString, RegexString&gt; Groups()const</td></tr>
<tr><td>[返回值]</td><td>命名捕一对多重映射，Regex允许一个名字下有多个捕获</td></tr>
</tbody>
</table>
<h2><a name="Regex">Regex</a></h2>
<p>正则表达式引擎</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员函数</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">Regex(const WString& code, bool preferPure=true)</td></tr>
<tr><td>code</td><td>正则表达式的字符串</td></tr>
<tr><td>preferPure</td><td>preferPure为true的话Regex会尽量使用一个大量优化的算法，不过这个优化要求正则表达式不含有捕获向前匹配、预查和非贪婪循环。</td></tr>

<tr><td colspan="2" class="method_sign">bool IsPureMatch()const</td></tr>
<tr><td>[返回值]</td><td>True代表Regex使用优化算法匹配</td></tr>

<tr><td colspan="2" class="method_sign">bool IsPureTest()const</td></tr>
<tr><td>[返回值]</td><td>True代表Regex使用优化算法寻找一个匹配</td></tr>

<tr><td colspan="2" class="method_sign">Ptr&lt;RegexMatch&gt; MatchHead(const WString& text)const</td></tr>
<tr><td>[返回值]</td><td>匹配字符串的前缀</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>

<tr><td colspan="2" class="method_sign">Ptr&lt;RegexMatch&gt; Match(const WString& text)const</td></tr>
<tr><td>[返回值]</td><td>在字符串中寻找一个匹配</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>

<tr><td colspan="2" class="method_sign">bool TestHead(const WString& text)const</td></tr>
<tr><td>[返回值]</td><td>True代表字符串的某个前缀是一个匹配</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>

<tr><td colspan="2" class="method_sign">bool TestBool(const WString& text)const</td></tr>
<tr><td>[返回值]</td><td>True代表字符串包含匹配</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>

<tr><td colspan="2" class="method_sign">void Search(const WString& text, RegexMatch::List& matches)const</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>
<tr><td>matches</td><td>所有的匹配</td></tr>

<tr><td colspan="2" class="method_sign">Split(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>
<tr><td>keepEmptyMatch</td><td>True代表所有空的非匹配部分会被丢弃</td></tr>
<tr><td>matches</td><td>字符串除去匹配之后剩下的所有非匹配部分</td></tr>

<tr><td colspan="2" class="method_sign">Cut(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const</td></tr>
<tr><td>text</td><td>输入的字符串</td></tr>
<tr><td>keepEmptyMatch</td><td>True代表所有空的非匹配部分会被丢弃</td></tr>
<tr><td>matches</td><td>所有匹配及非匹配部分</td></tr>
</tbody>
</table>
<h2><a name="RegexToken">RegexToken</a></h2>
<p>RegexToken记录一个词法记号的信息</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员变量</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">int start;</td></tr>
<tr><td>[返回值]</td><td>记号在输入字符串中的位置。</td></tr>

<tr><td colspan="2" class="method_sign">int length;</td></tr>
<tr><td>[返回值]</td><td>记号的长度。</td></tr>

<tr><td colspan="2" class="method_sign">int token;</td></tr>
<tr><td>[返回值]</td><td>记号的类型序号。类型序号是该记号的正则表达式描述出现在RegexLexer构造函数中的正则表达式列表中的位置。</td></tr>

<tr><td colspan="2" class="method_sign">const wchar_t* reading;</td></tr>
<tr><td>[返回值]</td><td>记号第一个字符在字符串中的指针位置。</td></tr>

<tr><td colspan="2" class="method_sign">int lineIndex;</td></tr>
<tr><td>[返回值]</td><td>记号的行号。</td></tr>

<tr><td colspan="2" class="method_sign">int lineStart;</td></tr>
<tr><td>[返回值]</td><td>记号在当前行中的位置。</td></tr>

<tr><td colspan="2" class="method_sign">int codeIndex;</td></tr>
<tr><td>[返回值]</td><td>记号的代码标识符。该标识符为RegexLexer::Parse中的参数。</td></tr>
</tbody>
</table>
<h2><a name="RegexTokens">RegexTokens</a></h2>
<p>RegexTokens记录一个词法记号列表</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员函数</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">collections::IEnumerator&lt;RegexToken&gt;* CreateEnumerator()const;</td></tr>
<tr><td>[返回值]</td><td>记号迭代器。当执行该迭代器的Next函数的时候，词法分析器将匹配并计算出一个记号。</td></tr>
</tbody>
</table>
<h2><a name="RegexLexer">RegexLexer</a></h2>
<p>词法分析器</p>
<p>关于正则表达式语法的信息请阅读<a href="#Grammar">正则表达式语法参考</a>。</p>
<table>
<thead><tr><td colspan="2" style="text-align:center; font-weight:bold">成员函数</td></tr>
<tr><td style="width:100">参数</td><td>说明</td></tr></thead>
<tbody>
<tr><td colspan="2" class="method_sign">RegexLexer(const collections::IEnumerable&lt;WString&gt;& tokens);</td></tr>
<tr><td>tokens</td><td>所有词法记号的正则表达式描述。正则表达式在该列表中的顺序将记录在RegexToken::token。</td></tr>

<tr><td colspan="2" class="method_sign">RegexTokens Parse(const WString& code, int codeIndex=-1);</td></tr>
<tr><td>code</td><td>待分析的字符串。</td></tr>
<tr><td>codeIndex</td><td>用户参数，仅供记录额外信息。</td></tr>
<tr><td>[返回值]</td><td>记号列表。</td></tr>
</tbody>
</table>
<h2><a name="Grammar">正则表达式语法参考</a></h2>
<p>Vczh Library++核心库中的正则表达式由以下几部分组成：</p>
<li><a href="#Char">字符和转义字符</a></li>
<li><a href="#Loop">重复</a></li>
<li><a href="#Seq">序列和分支</a></li>
<li><a href="#Capture">捕获</a></li>
<li><a href="#Back">捕获引用</a></li>
<li><a href="#Lookahead">正向预查和反向预查</a></li>
<li><a href="#Rename">子表达式命名</a></li>
<p>Regex的构造函数有一个叫preferPure的参数。如果preferPure是true的话，Regex会尽量使用一个快得多的算法来运行输入的正则表达式。下面的表格展示了正则表达式的哪一些功能支持这种快速算法。</p>
<table>
<thead><tr><td>功能</td><td>快速匹配</td><td>快速寻找匹配</td></tr></thead>
<tbody>
<tr><td>字符集</td><td>是</td><td>是</td></tr>
<tr><td>x{a}, x{a,}, x{a,b}, x+, x*, x?</td><td>是</td><td>是</td></tr>
<tr><td>ab, a|b</td><td>是</td><td>是</td></tr>
<tr><td>(&lt;name&gt;x), (?x)</td><td>否</td><td>是</td></tr>
<tr><td>$, ^</td><td>否</td><td>否</td></tr>
<tr><td>x{a}?, x{a,}?, x{a,b}?, x+?, x*?, x??</td><td>否</td><td>否</td></tr>
<tr><td>(&lt;$name&gt;), (&lt;$name;i&gt;)(&lt;i&gt;)</td><td>否</td><td>否</td></tr>
<tr><td>(=x), (!x)</td><td>否</td><td>否</td></tr>
</tbody>
</table>
<p><b>在接下来的部分我们用/x/表示正则表达式，用"x"表示文本。</b></p>
<h3><a name="Char">字符和转义字符</a></h3>
<p>正则表达式包含两种字符集合：普通字符和字符范围。这两种字符集合的表达方法使用不同的字符转义。</p>
<p>/a/可以表达"a"，/b/可以表达"b"，/\w/可以表达一个字母、数字或下划线。但是/^/和/$/并不是"^"和"$"。下面的表格描述了字符转义的详细法则</p>
<table>
<thead><tr><td>字符</td><td>意义</td><td>转义1</td><td>转义2</td><td>转义后的意义</td></tr></thead>
<tbody>
<tr><td>.</td><td>&quot;.&quot;</td><td>\.</td><td>/.</td><td>任意字符</td></tr>
<tr><td>r</td><td>&quot;r&quot;</td><td>\r</td><td>/r&nbsp;</td><td>0x0D(ASCII)</td></tr>
<tr><td>n</td><td>&quot;n&quot;</td><td>\n</td><td>/n</td><td>0x0A(ASCII)</td></tr>
<tr><td>t</td><td>&quot;t&quot;</td><td>\t</td><td>/t</td><td>制表符</td></tr>
<tr><td>\</td><td>&nbsp;</td><td>\\</td><td>/\</td><td>&quot;\&quot;</td></tr>
<tr><td>/</td><td>&nbsp;</td><td>\/</td><td>//</td><td>&quot;/&quot;</td></tr>
<tr><td>(</td><td>&nbsp;</td><td>\(</td><td>/(</td><td>&quot;(&quot;</td></tr>
<tr><td>)</td><td>&nbsp;</td><td>\)</td><td>/)</td><td>&quot;)&quot;</td></tr>
<tr><td>+</td><td>&nbsp;</td><td>\+</td><td>/+</td><td>&quot;+&quot;</td></tr>
<tr><td>*</td><td>&nbsp;</td><td>\*</td><td>/*</td><td>&quot;*&quot;</td></tr>
<tr><td>?</td><td>&nbsp;</td><td>\?</td><td>/?</td><td>&quot;?&quot;</td></tr>
<tr><td>{</td><td>&nbsp;</td><td>\{</td><td>/{</td><td>&quot;{&quot;</td></tr>
<tr><td>}</td><td>&nbsp;</td><td>\}</td><td>/}</td><td>&quot;}&quot;</td></tr>
<tr><td>[</td><td>&nbsp;</td><td>\[</td><td>/[</td><td>&quot;[&quot;</td></tr>
<tr><td>]</td><td>&nbsp;</td><td>\]</td><td>/]</td><td>&quot;]&quot;</td></tr>
<tr><td>&lt;</td><td>&nbsp;</td><td>\&lt;</td><td>/&lt;</td><td>&quot;&lt;&quot;</td></tr>
<tr><td>&gt;</td><td>&nbsp;</td><td>\&gt;</td><td>/&gt;</td><td>&quot;&gt;&quot;</td></tr>
<tr><td>^</td><td>字符串开始处</td><td>\^</td><td>/^</td><td>&quot;^&quot;</td></tr>
<tr><td>$</td><td>字符串结尾处</td><td>\$</td><td>/$</td><td>&quot;$&quot;</td></tr>
<tr><td>!</td><td>&nbsp;</td><td>\!</td><td>/!</td><td>&quot;!&quot;</td></tr>
<tr><td>=</td><td>&nbsp;</td><td>\=</td><td>/=</td><td>&quot;=&quot;</td></tr>
<tr><td>S</td><td>&quot;S&quot;</td><td>\S</td><td>/S</td><td>非/s</td></tr>
<tr><td>s</td><td>&quot;s&quot;</td><td>\s</td><td>/s</td><td>空格、0x0D、0x0A或制表符</td></tr>
<tr><td>D</td><td>&quot;D&quot;</td><td>\D</td><td>/D</td><td>非 /d</td></tr>
<tr><td>d</td><td>&quot;d&quot;</td><td>\d</td><td>/d</td><td>数字字符</td></tr>
<tr><td>L</td><td>&quot;L&quot;</td><td>\L</td><td>/L</td><td>非 /l</td></tr>
<tr><td>l</td><td>&quot;l&quot;</td><td>\l</td><td>/l</td><td>字母或数字</td></tr>
<tr><td>W</td><td>&quot;W&quot;</td><td>\W</td><td>/W</td><td>非/w</td></tr>
<tr><td>w</td><td>&quot;w&quot;</td><td>\w</td><td>/w</td><td>字符、数字或下环线</td></tr>
</tbody>
</table>
<p>我们可以用字符范围来表达字符集合的复杂规则。例如/[a-c]/代表"a"、"b"或"c"，/[a-zA-Z0-9_]/代表字母、数字或下划线。如果使用[^...]，则对规则取反。例如/[^a-zA-Z]/代表不是字母的字符。</p>
<p>字符范围里面的转义规则跟上面的那张表有很大的不同：</p>
<table>
<thead><tr><td>字符</td><td>意义</td><td>转义1</td><td>转义2</td><td>转义后的意义</td></tr></thead>
<tbody>
<tr><td>.</td><td>&quot;.&quot;</td><td>\.</td><td>/.</td><td>任意字符</td></tr>
<tr><td>r</td><td>&quot;r&quot;</td><td>\r</td><td>/r&nbsp;</td><td>0x0D(ASCII)</td></tr>
<tr><td>n</td><td>&quot;n&quot;</td><td>\n</td><td>/n</td><td>0x0A(ASCII)</td></tr>
<tr><td>t</td><td>&quot;t&quot;</td><td>\t</td><td>/t</td><td>制表符</td></tr>
<tr><td>-</td><td>&nbsp;</td><td>\-</td><td>/-</td><td>&quot;-&quot;</td></tr>
<tr><td>\</td><td>&nbsp;</td><td>\\</td><td>/\</td><td>&quot;\&quot;</td></tr>
<tr><td>/</td><td>&nbsp;</td><td>\/</td><td>//</td><td>&quot;/&quot;</td></tr>
<tr><td>[</td><td>&nbsp;</td><td>\[</td><td>/[</td><td>&quot;[&quot;</td></tr>
<tr><td>]</td><td>&nbsp;</td><td>\]</td><td>/]</td><td>&quot;]&quot;</td></tr>
<tr><td>^</td><td>字符串开始处</td><td>\^</td><td>/^</td><td>&quot;^&quot;</td></tr>
<tr><td>$</td><td>字符串结尾处</td><td>\$</td><td>/$</td><td>&quot;$&quot;</td></tr>
</tbody>
</table>
<h3><a name="Loop">重复</a></h3>
<p>重复可以表达一些连续重复出现的模式，下面有正则表达式支持的所有重复种类：</p>
<table>
<thead>
<tr><td>重复模式</td><td>意义</td></tr>
</thead>
<tbody>
</tbody>
<tr><td>X+</td><td>一或多个X</td></tr>
<tr><td>X?</td><td>零、一或多个X</td></tr>
<tr><td>X*</td><td>零或一个X</td></tr>
<tr><td>X{3}</td><td>三个X</td></tr>
<tr><td>X{3,}</td><td>三个或以上X</td></tr>
<tr><td>X{3,5}</td><td>三、四或五个X</td></tr>
</table>
<p>如果一个问号紧接着一个重复模式，那么该重复被定义为尽可能早结束。</p>
<p>举个例子，/a+/匹配"aaa"里面的"aaa"而/a+?/则匹配"aaa"里面的"a"。但是/a+b/和/a+?b/都匹配"aaab"里面的"aaab"。</p>
<h3><a name="Seq">序列和分支</a></h3>
<p>序列代表多个模式按顺序出现。如果我们需要匹配一个电子邮箱地址如"vczh@163.com"或"vczh@hotmail.com"，我们序号：</p>
<p><b>\w+@\w+.\w+</b></p>
<p>这是一个组合了/w+/、/@/、/\w+/、/./和/w+/的序列。这五个序列按照定义的顺序出现。在/w+@w+.w+/匹配"vczh@163.com"的时候，我们得到下面的结果：<br />
/w+/ = "vczh"<br />
/@/ = "@"<br />
/w+/ = "163"<br />
/./ = "."<br />
/w+/ = "com"</p>
<p>分支代表多个模式中的其中一个出现，例如/a|b|c/代表[abc]，而/ab|ac|de/代表"ab"、"ac"或"de"序列的优先级比分支高。</p>
<h3><a name="Capture">捕获</a></h3>
<p>捕获可以用来获取正则表达式分析过程中更为细微的结果。捕获允许Regex将匹配过程中子模式匹配到的部分存下来，然后放到一个Group结构中去。</p>
<p>举个例子，如果你想知道Email地址中的用户名和服务器名，你可以使用/(&lt;NAME&gt;\w+)@(&lt;SERVER&gt;\w+.\w+)/。当你获得一个匹配（RegexMatch）之后，你能用match.Groups()[L"NAME"][0]和match.Groups()[L"SERVER"][0]分别获得它们。</p>
<p>一个名字下面可以同时存放几个子字符串。</p>
<p>第一个例子是/(&lt;GROUP&gt;\d+).(&lt;GROUP&gt;\d+)/。它将一个实数分析成整数部分和小数部分，然后都存放到"GROUP"的组下面去。</p>
<p>第二个例子是((&lt;GROUP&gt;\d+),)*(&lt;GROUP&gt;\d+)。他将一个用逗号隔开的整数列表（如"12,345,6"）的所有整数都拿出来放到"GROUP"的组下面去。</p>
<p>捕获不仅可以命名，同时也可以匿名。匿名捕获跟命名捕获一样，仅仅是名字为空。你<b>不能</b>用/(&lt;&gt;expression)/去构造一个匿名捕获，正确的语法是/(?expression)/。</p>
<p>到此为止，我们有两种捕获：<br />
命名捕获：/(&lt;NAME&gt;expression)/<br />
匿名捕获：/(?expression)/</p>
<h3><a name="Back">捕获引用</a></h3>
<p>捕获引用提供了一种把新的字符串跟已经捕获的字符串相比较的方法。Regex提供三种捕获引用：</p>
<p>(&lt;$NAME&gt;)：匹配跟这个组下的其中一个捕获一样的字符串。</p>
<p>(&lt;$NAME:i&gt;)匹配这个组下面第i个捕获一样的字符串。</p>
<p>(&lt;$i&gt;)匹配第i个匿名捕获。</p>
<p>这里i从0开始，不能是负的。提供一个超出范围的i仅仅导致匹配失败，而不会让Regex抛出异常。</p>
<p>这里有一个例子匹配一个字符串是不是由一个小字符串重复拼接而成的，如"aaaaa"、"abCabCabC"和"1,1,1,1,1,"：/<font color="red">(?\.+?)(&lt;$0&gt;)+</font>/。<br />
这里/(?\.+?)/尝试获取第一个字符，然后用捕获引用检查接下来的字符串是不是都由这个字符组成。如果失败了，那么就尝试两个、三个甚至更多的字符串，直到找到一个解或者没有任何解为之。</p>
<h3><a name="Lookahead">正向预查和反向预查</a></h3>
<p>正向预查和反向预查可以用来检查一个匹配是否满足额外的条件。譬如：<br />
我们需要找到一个后面是"2000"的"windows"，可以使用/windows(=2000)/<br />
我们需要找到一个后面不是"2000"的"windows"，则可以使用/windows(!2000)/</p>
<p>条件部分可以是任何正则表达式，举个例子：<br />
我们需要找到一个"email"，其后紧接着一些符号，还有一个真正的Email地址，我们可以使用/email(=\W*\w+@\w+.\w+)/<br />
</p>
<h3><a name="Rename">子表达式命名</a></h3>
<p>子表达式是一种让正则表达式变得可读、紧凑并且可以消除重复子表达式地方法。</p>
<p>如果我们需要一个匹配IPv4地址的正则表达式，并且检查每一个部分是否在0到255的范围内。<br />
首先，我们用/25[0-5]|2[0-3]\d|1\d\d|[1-9]\d|\d/来检查一个整数是否属于那个范围，命名为BYTE。<br />
其次，我们用/((&lt;&BYTE&gt;).){3}(&lt;&BYTE&gt;)来拼成一个IPv4地址的正则表达式。<br />
最后，将它们放在一起组成一条完整的正则表达式：/(&lt;#BYTE&gt;<font color="red">25[0-5]|2[0-3]\d|1\d\d|[1-9]\d|\d</font>)<font color="blue">((&lt;&BYTE&gt;).){3}(&lt;&BYTE&gt;)</font>/。</p>
<p>我们不需要重复复制一些部分。在没有子表达式命名的时候我们只能写/(<font color="red">25[0-5]|2[0-3]\d|1\d\d|[1-9]\d|\d</font>.){3}<font color="red">25[0-5]|2[0-3]\d|1\d\d|[1-9]\d|\d</font>/。</p>
<p>一个正则表达式可以为多个子表达式命名，但是每一个表达式或者命名只能使用在他之前定义好的子表达式。</p>
<p>举个例子，/(&lt;#A&gt;a)(&lt;#As&gt;(&lt;&amp;A&gt;)+)(&lt;&amp;As&gt;).(&lt;&amp;As&gt;)/（等价于/a+.a+/）是正确的。<br />
而/(&lt;#As&gt;(&lt;&amp;A&gt;)+)(&lt;#A&gt;a)(&lt;&amp;As&gt;).(&lt;&amp;As&gt;)/则是错误的。</p>
<p>子表达式命名并不是模式的一部分，真正匹配的部分应当放在最后，一个正则表达式不能出了子表达式命名而没有真正匹配的模式。</p>
</body>
</html>