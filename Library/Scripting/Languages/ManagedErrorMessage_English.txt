resource:vl.scripting.managedlanguage.ManagedErrorMessage

SymbolAlreadyDefined(name)=Symbol {name} already defined.
NamespaceNotExists(name)=Namespace {name} does not exists.
FullPathTypeNotExists(name)=Type {name} does not exist.
FullPathTypeDuplicated(name)=Multiple types of {name} found.
ScopedTypeNotExists(name)=Type {name} does not exist in the current scope.
ScopedTypeDuplicated(name)=Multiple types of {name} found in the current scope.
IllegalAutoRefer(autoRefType)=The Auto refer type \"{autoRefType}\" can only be used in variable declaration statement, using statement, foreach statement and lambda expression parameter/return type.
CannotDirectReferTypeRenameAsToplevel(name)=Type rename declaration {name} cannot target to a type whose top level type is another type rename declaration.
IllegalNestedDeclaration=Only class, structure, interface, enumeration and type rename can be defined as a nested type.
TypeInvisible(name)=Type {name} is invisible at the current scope.
TypeInvisibleOutSideOfAssembly(name)=The accessor of type {name} is incompatible of the current declaration so that it is invisible out side of the assembly.
CannotUseUninstantiatedGenericType(name)=Cannot use uninstantiated type {name} as generic argument or to declare object.
GenericTypeArgumentCountNotMatches(name)=Generic argument count of type {name} do not match the declaration.
GenericTypeTypeConstraintNotSatisfied(name,index)=The {index}th generic argument of type {name} does not satisfies the required type constraint.
GenericTypeNewConstraintNotSatisfied(name,index)=The {index}th generic argument of type {name} does not satisfies the required new constraint.

TypeCannotDerivedFromItself(name)=Type {name} cannot derived from itself directly or indirectly.
ClassIllegalBaseClass(name)=Class {name} can only derived from a non-sealed class.
StructureIllegalBaseClass(name)=Structure {name} can only derived from Object or a non-sealed structure with StructBaseAttribute.
InterfaceIllegalBaseClass(name)=Interface {name} can only derived from other interfaces.
StaticTypeIllegalBaseClass(name)=Static type {name} can only derived from static type.
ClassStructureTooMuchBaseClasses(name)=Type {name} can only derived from one non-interface type.
ClassStructureIllegalInheritation(name)=Type {name} cannot be virtual or overrided.
InterfaceIllegalInheritation(name)=Interface {name} should be abstract.
InterfaceIllegalMemberType(name)=Interface {name} cannot be static.
StaticTypeIllegalInheritance(name)=Static type {name} cannot be abstract, virtual or override.
TypeIllegalAccessor(name)=Type {name} cannot be protected or protected internal when it is not a sub type.
InterfaceMemberIllegalType(name,member)=Member {member} cannot be declared in interface {name} because it is not a property, a method or a converter operator.
InterfaceMemberIllegalAccessor(name,member)=Member {member} in interface {name} should be public.
InterfaceMemberIllegalMemberType(name,member)=Member {member} in interface {name} cannot be static.
InterfaceMemberIllegalInheritation(name,member)=Member {member} in interface {name} should be abstract.
InterfaceMemberIllegalImplementedInterface(name,member)=Member {member} in interface {name} cannot specify an implemented interface type.
SealedTypeMemberIllegalAccessor(name,member)=Member {member} in sealed type {name} can only be private, internal or public.
SealedTypeMemberIllegalInheritance(name,member)=Member {member} in sealed type {name} cannot be abstract or virtual.
StaticTypeMemberIllegalAccessor(name,member)=Member {member} in static type {name} can only be private, internal or public.
StaticTypeMemberIllegalInheritance(name,member)=Member {member} in static type {name} cannot be abstract, virtual or override.
StaticTypeMemberIllegalMemberType(name,member)=Member {member} in static type {name} can only be static.
NonAbstractTypeMemberIllegalInheritance(name,member)=Abstract member {member} cannot be declared in non-abstract type {name}.
InterfaceImplementedMemberIllegalMemberType(name,member)=Member {member} with an implemented interface type in type {name} cannot be static.
InterfaceImplementedMemberIllegalInheritation(name,member)=Member {member} with an implemented interface type in type {name} cannot be override.
MemberImplementedInterfaceTypeNotExists(name,member)=The interface type specified in member {member} is not derived by type {type}.
MemberOverridedTargetNotExists(name,member)=Member {member} in type {type} cannot find a correct member to override.
MemberOverridedTargetIllegalAccessor(name,member)=Member {member} in type {type} find a correct member to override, but the accessor doesn't match.

ExpressionResolvedToDuplicatedTargets=Expression resolved to duplicated targets.
ExpressionResolvedToDuplicatedTargets(type)=Expression resolved to duplicated targets which converts to type {type}.
ExpressionResolvingFailed(name)=Failed to resolve symbol {name}.
ExpressionCannotConvertToType(type)=Expression cannot convert to type {type}.
IllegalAutoRefWithoutInitializer(name,autoRefType)=Variable type cannot be \"{autoRefType}\" if it doesn't have an initializer.
VariableAlreadyExists(name)=Variable {name} already exists.
IllegalBreak=Break statement can only be used in loop or switch statement.
IllegalContinue=Continue statement can only be used in loop statement.
IllegalThrow=Rethrow statement can only be used in catch clause.
ExceptionTypeShouldDerivedFromException(type,exceptionType)=Exceptions should derived from {exceptionType}, but {type} does not.
IllegalThis(expr)=Expression {expr} is only accessible in non-static methods, non-static converter operators and constructors.
IllegalBase(expr)=Expression {expr} is only accessible in non-static methods, non-static converter operators and constructors of a class or structure that has a base class or structure.
ExpressionIsNotValue(expr)=Expression \"{expr}\" cannot be evaluated to a value.
MatchedMethodNotExists(expr)=Cannot find a matched method or operator of expression \"{expr}\".
MatchedMethodTooMuch(expr)=Matched method or operator of expression \"{expr}\" too much.
IllegalNull(expr)=Cannot use {expr} without context.