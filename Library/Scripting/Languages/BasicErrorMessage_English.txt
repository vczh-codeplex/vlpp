resource:vl.scripting.basiclanguage.BasicErrorMessage

TypeNameNotExists(type)=Type {type} does not exists.
FunctionAlreadyExists(name)=Function {name} already exists.
VariableAlreadyExists(name)=Variable {name} already exists.
TypeAlreadyExists(name)=Type {name} already exists.
StructureMemberAlreadyExists(name)=Member {name} already exists.
VariableNotExists(name)=Variable {name} not exists.
FailToCast(from,to)=Fail to cast from {from} to {to}.
VoidFunctionNotHaveResult=Cannot access function result in a function without return value.
GlobalNotHaveResult=Cannot access function result in global definitions.
CannotInvokeNonFunctionValue(type)=Cannot invoke a value of {type}.
ArgumentNumnerNotMatch=Argument number should not be greater or less than the function required.
ArgumentTypeNotMatch(index,from,to)=Cannot implicitly cast argument {index} from {from} to {to}.
StructureMemberNotExists(name)=Member {name} not exists.
CannotConvertIndexToInt(from,to)=Cannot implicit cast the index from {from} to {to}.
CannotSubscribe(type)=Cannot subscribe a value of {type}.
UnaryOperandShouldBeLeftValue=Operand should be left value.
UnaryTypeNotMatch(op,type)=Unary operator {op} cannot apply to a value of {type}.
BinaryLeftOperandShouldBeLeftValue(op)=Left operand of binary operator {op} should be left value.
BinaryTypeNotMatch(op,left,right)=Binary operator {op} cannot apply to values of {left} and {right}.
ConditionCannotConvertToBool(from,boolean)=Cannot convert the condition from {from} to {boolean}.
BreakShouldBeInLooping(breakStatement)={breakStatement} should be used in a loop.
ContinueShouldBeInLooping(continueStatement)={continueStatement} should be used in a loop.
InitializerTypeNotMatch(from,to)=Cannot convert the variable initializer from {from} to {to}.
ParameterCountNotMatch=Parameter number should not be greater or less than the function required.
ParameterAlreadyExists(name)=Parameter {name} already exists.
StructureMemberCannotBeUndefinedType(name)=Cannot refer to an undefined structure in member {name}.
LeftOperandShouldBeStructure=Left operand should be a structure.
LeftOperandShouldBePointerToStructure=Left operand should be a pointer to a structure.
PredeclaredStructureShouldBeDefined(name)=Predeclared structure {name} should be defined.
ExternalFunctionCannotHaveStatement(name)=External function {name} cannot have a statement.
LocalFunctionShouldHaveStatement(name)=Local function {name} should have a statement.
ExternalVariableCannotHaveInitializer(name)=External variable {name} cannot have an initializer.
ExternalStructureShouldBeDefined(name)=External structure {name} should be defined.
GenericArgumentAlreadyExists(declaration,name)=Generic argument {name} duplicated in declaration {declaration}.
GenericArgumentNotExists(declaration,name)=Generic argument {name} does not exist in declaration {declaration}.
CannotUseUninstanciatedGenericType=Cannot use uninstanciated generic types.
CannotUseUninstanciatedGenericVariable(name)=Cannot use uninstanciated generic variable {name}.
CannotUseUninstanciatedGenericFunction(name)=Cannot use uninstanciated generic function {name}.
GenericArgumentNumberNotMatch=Generic argument number should not be greater or less than the generic type required.
GenericArgumentCannotApplyToNonGenericType=Generic argument cannot apply to non-generic type.
ConceptFunctionAlreadyExists(name,function)=Concept {name} already have a function called {function}.
ConceptFunctionNotExists(name,function)=Concept {name} does not have a function called {function}.
ConceptAlreadyExists(name)=Concept {name} already exists;
ConceptNotExists(name)=Concept {name} not exists.
InstanceTypeNotCorrect(name)=Instance {name} can only apply to primitive types or raw generic types.
ConceptFunctionTypeNotMatches(name,function)=Concept {name} has a function {function} with a different type.
InstanceShouldHaveFunction(name,function)=Instance {name} should have a function {function}.
InstanceShouldNotHaveFunction(name,function)=Concept {name} should not have a function {function}.
InstanceShouldBeDeclaredOnType(type,conceptName)=An instance of concept {conceptName} on type {type} is needed.
CannotThrowVoidValue=Cannot throw an expression that returns no value.
ForeignFunctionCannotBeGeneric(name)=Foreign function {name} cannot be generic.

AttributeCannotApplyOnFunctionDeclaration(attribute,name)=Attribute {attribute} cannot apply on function declaration {name}.
AttributeCannotApplyOnStructureDeclaration(attribute,name)=Attribute {attribute} cannot apply on structure declaration {name}.
AttributeCannotApplyOnVariableDeclaration(attribute,name)=Attribute {attribute} cannot apply on variable declaration {name}.
AttributeCannotApplyOnTypeRenameDeclaration(attribute,name)=Attribute {attribute} cannot apply on type rename declaration {name}.
AttributeCannotApplyOnConceptDeclaration(attribute,name)=Attribute {attribute} cannot apply on concept declaration {name}.
AttributeCannotApplyOnInstanceDeclaration(attribute,name)=Attribute {attribute} cannot apply on instance declaration {name}.
PublicDeclarationCannotUseNonPublicType(name,type)=Public declaration {name} cannot use non public type {type}.
InstanceDeclaredOnPublicConceptShouldBePublic(concept)=Instance declared on public concept {concept} should be public.
InstanceDeclaredOnNonPublicConceptShouldBeNonPublic(concept)=Instance declared on non public concept {concept} should be non public.

ArrayElementCountShouldBeIntegerConstantExpression=Array element count should be integer constant expression.
ArrayElementCountShouldBePositive=Array element count should be positive.

ILExceptionStackOverflow=Stack overflow.
ILExceptionDividByZero=Divided by zero.
ILExceptionAccessViolation=Access violation.
ILExceptionInstructionIndexOutOfRange=Instruction index out of range.
ILExceptionUnknownInstruction=Unknown instruction.
ILExceptionBadInstructionArgument=Bad instruction argument.
ILExceptionUnhandledException=Unhandled exception raised.

ILLinkerExceptionDuplicatedAssemblyName(assembly)=Assembly {assembly} exists. Cannot load an assembly that conflict with existing names.
ILLinkerExceptionAssemblyNotExists(assembly)=Assembly {assembly} has not been loaded.
ILLinkerExceptionDuplicatedSymbolName(assembly,symbol)=Symbol {symbol} in assembly {assembly} exists. Assembly cannot have two symbols of the same name.
ILLinkerExceptionSymbolNotExists(assembly,symbol)=Cannot find symbol {symbol} in assembly {assembly}.
ILLinkerExceptionSymbolNotALabel(assembly,symbol)=Symbol {symbol} in assembly {assembly} does not associated with an instruction entry.
ILLinkerExceptionDuplicatedInstance(name)=Instance {name} already exists.
ILLinkerExceptionForeignFunctionNotExists(assembly,symbol)=Cannot find foreign function {assembly}::{symbol}.