using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.CodeDom.Compiler;
using System.CodeDom;

namespace NodeService.Endpoints
{
    public abstract class StrongTypedNodeEndpointClient : INodeEndpointClient
    {
        private static Dictionary<Type, Type> clientImplementations = new Dictionary<Type, Type>();

        private INodeEndpointClientProvider provider;
        private StrongTypedNodeEndpointSerializer serializer;

        public StrongTypedNodeEndpointClient(INodeEndpointClientProvider provider)
        {
            this.provider = provider;
            this.serializer = new StrongTypedNodeEndpointSerializer();
        }

        public INodeEndpointClientProvider Provider
        {
            get
            {
                return this.provider;
            }
        }

        public void Dispose()
        {
            if (this.provider.Protocol != null)
            {
                this.provider.Protocol.Disconnect();
            }
        }

        protected object Execute(string method, Type type, string[] names, object[] arguments)
        {
            XElement body = new XElement("Parameters",
                names
                .Zip(arguments, (a, b) => Tuple.Create(a, b))
                .Select(t => new XElement(t.Item1, this.serializer.Serialize(t.Item2)))
                );
            var response = this.provider.Send(method, body);
            response.WaitForResponse();
            if (response.RequestState == RequestState.RaisedException)
            {
                throw response.Exception;
            }
            else if (type != typeof(void))
            {
                return this.serializer.Deserialize(response.Response, type);
            }
            else
            {
                return null;
            }
        }

        private static Type CreateClientImplementation(Type infertaceType)
        {
            Type clientType = null;
            if (!clientImplementations.TryGetValue(infertaceType, out clientType))
            {

                CodeDomProvider codedomProvider = CodeDomProvider.CreateProvider("CSharp");
                string namespaceName = "NodeService.StringTypedNodeEndpointClientAutoGeneratedClients";
                string typeName = "ImplementationOf" + infertaceType.Name;

                CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
                {
                    CodeNamespace codeNamespace = new CodeNamespace(namespaceName);
                    codeCompileUnit.Namespaces.Add(codeNamespace);

                    CodeTypeDeclaration clientDeclaration = new CodeTypeDeclaration(typeName);
                    clientDeclaration.BaseTypes.Add(typeof(StrongTypedNodeEndpointClient));
                    clientDeclaration.BaseTypes.Add(infertaceType);
                    codeNamespace.Types.Add(clientDeclaration);

                    CodeConstructor clientConstructor = new CodeConstructor();
                    clientDeclaration.Members.Add(clientConstructor);
                    clientConstructor.Attributes = MemberAttributes.Public;
                    clientConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(INodeEndpointClientProvider), "provider"));
                    clientConstructor.BaseConstructorArgs.Add(new CodeArgumentReferenceExpression("provider"));

                    foreach (var methodInfo in infertaceType.GetMethods())
                    {
                        CodeMemberMethod clientMethod = new CodeMemberMethod();
                        clientDeclaration.Members.Add(clientMethod);
                        clientMethod.Attributes = MemberAttributes.Public;
                        clientMethod.Name = methodInfo.Name;
                        clientMethod.ImplementationTypes.Add(infertaceType);
                        clientMethod.ReturnType = new CodeTypeReference(methodInfo.ReturnType);
                        foreach (var parameterInfo in methodInfo.GetParameters())
                        {
                            clientMethod.Parameters.Add(new CodeParameterDeclarationExpression(parameterInfo.ParameterType, parameterInfo.Name));
                        }

                        CodeExpression execution = new CodeMethodInvokeExpression(
                            new CodeThisReferenceExpression(),
                            "Execute",
                            new CodeExpression[] { 
                            new CodePrimitiveExpression(methodInfo.Name) ,
                            new CodeTypeOfExpression(methodInfo.ReturnType),
                            new CodeArrayCreateExpression(
                                typeof(string),
                                methodInfo
                                    .GetParameters()
                                    .Select(p => new CodePrimitiveExpression(p.Name))
                                    .ToArray()
                                ),
                            new CodeArrayCreateExpression(
                                typeof(object),
                                methodInfo
                                    .GetParameters()
                                    .Select(p => new CodeArgumentReferenceExpression(p.Name))
                                    .ToArray()
                                ),
                        }
                            .ToArray()
                        );

                        if (methodInfo.ReturnType == typeof(void))
                        {
                            clientMethod.Statements.Add(
                                new CodeExpressionStatement(
                                    execution
                                    )
                                );
                        }
                        else
                        {
                            clientMethod.Statements.Add(
                                new CodeMethodReturnStatement(
                                    new CodeCastExpression(
                                        methodInfo.ReturnType,
                                        execution
                                        )
                                    )
                                );
                        }
                    }
                }

                CompilerParameters options = new CompilerParameters();
                options.GenerateExecutable = false;
                options.GenerateInMemory = true;
                options.IncludeDebugInformation = false;
                options.ReferencedAssemblies.AddRange(
                    new string[] { typeof(StrongTypedNodeEndpointClient).Assembly.Location, infertaceType.Assembly.Location }
                    .Concat(typeof(StrongTypedNodeEndpointClient).Assembly.GetReferencedAssemblies().Select(n => n.CodeBase))
                    .Concat(infertaceType.Assembly.GetReferencedAssemblies().Select(n => n.CodeBase))
                    .Distinct()
                    .ToArray()
                );

                CompilerResults result = codedomProvider.CompileAssemblyFromDom(options, codeCompileUnit);
                codedomProvider.Dispose();
                clientType = result.CompiledAssembly.GetType(namespaceName + "." + typeName);
                clientImplementations.Add(infertaceType, clientType);
            }
            return clientType;
        }

        public static T Create<T>(INodeEndpointClientProvider provider)
            where T : INodeEndpointClient
        {
            Type clientType = CreateClientImplementation(typeof(T));
            return (T)clientType
                .GetConstructor(new Type[] { typeof(INodeEndpointClientProvider) })
                .Invoke(new object[] { provider });
        }
    }
}
