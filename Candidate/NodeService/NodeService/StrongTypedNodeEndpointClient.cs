using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.CodeDom.Compiler;
using System.CodeDom;

namespace NodeService
{
    public abstract class StrongTypedNodeEndpointClient : INodeEndpointClient
    {
        private INodeEndpointClientProvider provider;
        private StrongTypedNodeEndpointSerializer serializer;

        public StrongTypedNodeEndpointClient(INodeEndpointClientProvider provider)
        {
            this.provider = provider;
            this.serializer = new StrongTypedNodeEndpointSerializer();
        }

        public INodeEndpointClientProvider Provider
        {
            get
            {
                return this.provider;
            }
        }

        public void Dispose()
        {
            this.provider.Disconnect();
        }

        protected object Execute(string method, Type type, string[] names, object[] arguments)
        {
            XElement body = new XElement("Parameters",
                names
                .Zip(arguments, (a, b) => Tuple.Create(a, b))
                .Select(t => new XElement(t.Item1, this.serializer.Serialize(t.Item2)))
                );
            var response = this.provider.Send(method, body);
            response.WaitForResponse();
            if (response.RequestState == RequestState.RaisedException)
            {
                throw response.Exception;
            }
            else if (type != typeof(void))
            {
                return this.serializer.Deserialize(response.Response, type);
            }
            else
            {
                return null;
            }
        }

        public static T Create<T>(INodeEndpointClientProvider provider)
            where T : INodeEndpointClient
        {
            CodeDomProvider codedomProvider = CodeDomProvider.CreateProvider("CSharp");
            string namespaceName = "NodeService.StringTypedNodeEndpointClientAutoGeneratedClients";
            string typeName = "ImplementationOf" + typeof(T).Name;

            CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
            {
                CodeNamespace codeNamespace = new CodeNamespace(namespaceName);
                codeCompileUnit.Namespaces.Add(codeNamespace);

                CodeTypeDeclaration clientDeclaration = new CodeTypeDeclaration(typeName);
                clientDeclaration.BaseTypes.Add(typeof(StrongTypedNodeEndpointClient));
                clientDeclaration.BaseTypes.Add(typeof(T));
                codeNamespace.Types.Add(clientDeclaration);

                CodeConstructor clientConstructor = new CodeConstructor();
                clientDeclaration.Members.Add(clientConstructor);
                clientConstructor.Attributes = MemberAttributes.Public;
                clientConstructor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(INodeEndpointClientProvider), "provider"));
                clientConstructor.BaseConstructorArgs.Add(new CodeArgumentReferenceExpression("provider"));

                foreach (var methodInfo in typeof(T).GetMethods())
                {
                    CodeMemberMethod clientMethod = new CodeMemberMethod();
                    clientDeclaration.Members.Add(clientMethod);
                    clientMethod.Attributes = MemberAttributes.Public;
                    clientMethod.Name = methodInfo.Name;
                    clientMethod.ImplementationTypes.Add(typeof(T));
                    clientMethod.ReturnType = new CodeTypeReference(methodInfo.ReturnType);
                    foreach (var parameterInfo in methodInfo.GetParameters())
                    {
                        clientMethod.Parameters.Add(new CodeParameterDeclarationExpression(parameterInfo.ParameterType, parameterInfo.Name));
                    }

                    CodeExpression execution = new CodeMethodInvokeExpression(
                        new CodeThisReferenceExpression(),
                        "Execute",
                        new CodeExpression[] { 
                            new CodePrimitiveExpression(methodInfo.Name) ,
                            new CodeTypeOfExpression(methodInfo.ReturnType),
                            new CodeArrayCreateExpression(
                                typeof(string),
                                methodInfo
                                    .GetParameters()
                                    .Select(p => new CodePrimitiveExpression(p.Name))
                                    .ToArray()
                                ),
                            new CodeArrayCreateExpression(
                                typeof(object),
                                methodInfo
                                    .GetParameters()
                                    .Select(p => new CodeArgumentReferenceExpression(p.Name))
                                    .ToArray()
                                ),
                        }
                        .ToArray()
                    );

                    if (methodInfo.ReturnType == typeof(void))
                    {
                        clientMethod.Statements.Add(
                            new CodeExpressionStatement(
                                execution
                                )
                            );
                    }
                    else
                    {
                        clientMethod.Statements.Add(
                            new CodeMethodReturnStatement(
                                new CodeCastExpression(
                                    methodInfo.ReturnType,
                                    execution
                                    )
                                )
                            );
                    }
                }
            }

            CompilerParameters options = new CompilerParameters();
            options.GenerateExecutable = false;
            options.GenerateInMemory = true;
            options.IncludeDebugInformation = false;
            options.ReferencedAssemblies.AddRange(
                new string[] { typeof(StrongTypedNodeEndpointClient).Assembly.Location, typeof(T).Assembly.Location }
                .Concat(typeof(StrongTypedNodeEndpointClient).Assembly.GetReferencedAssemblies().Select(n => n.CodeBase))
                .Concat(typeof(T).Assembly.GetReferencedAssemblies().Select(n => n.CodeBase))
                .Distinct()
                .ToArray()
            );

            CompilerResults result = codedomProvider.CompileAssemblyFromDom(options, codeCompileUnit);
            codedomProvider.Dispose();
            Type clientType = result.CompiledAssembly.GetType(namespaceName + "." + typeName);
            return (T)clientType
                .GetConstructor(new Type[] { typeof(INodeEndpointClientProvider) })
                .Invoke(new object[] { provider });
        }
    }

    public interface INodeEndpointClientProvider
    {
        bool EnableAsynchronization { get; }
        bool Connected { get; }

        INodeEndpointResponse Send(string method, XElement body);
        void Disconnect();
    }

    public interface INodeEndpointClient : IDisposable
    {
        INodeEndpointClientProvider Provider { get; }
    }
}
